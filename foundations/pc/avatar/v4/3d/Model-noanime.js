/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

const PATH = "/3d/avatars-test/1205.glb";
const ANIMATIONS_URL = "/3d/avatars-test/talking.glb";

import React, { useRef, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { MathUtils } from "three";

import useBlink from "../utils/useBlink";
import useViseme from "../utils/useViseme";
import { VISME_TO_MORPHTARGET_MAP } from "../utils/constant";

export default function Model({
  position = [0, 0, 0],
  scale = [1, 1, 1],
  rotation = [0, 0, 0],
  ...props
}) {
  const group = useRef();
  const { nodes, materials } = useGLTF(PATH);
  const { visemeMessage } = useViseme();
  const { blink } = useBlink();

  // LERP MORPH TARGET
  const lerpMorphTarget = (target, value, speed = 0.1) => {
    group.current?.traverse((child) => {
      // console.log(child, child.isSkinnedMesh, child.morphTargetDictionary);
      if (child.isSkinnedMesh && child.morphTargetDictionary) {
        if (target === "eyeBlinkLeft") {
          console.log(
            child,
            child.isSkinnedMesh,
            child.morphTargetDictionary,
            target,
            child.morphTargetDictionary[target]
          );
        }

        const index = child.morphTargetDictionary[target];
        if (
          index === undefined ||
          child.morphTargetInfluences[index] === undefined
        ) {
          return;
        }
        child.morphTargetInfluences[index] = MathUtils.lerp(
          child.morphTargetInfluences[index],
          value,
          speed
        );
      }
    });
  };

  // Handle visemes and blinking
  useFrame(() => {
    // Smile
    lerpMorphTarget("mouthSmile", 0.5, 0.2);
    // Blinking
    lerpMorphTarget("eyeBlinkLeft", blink ? 1 : 0, 0.2);
    lerpMorphTarget("eyeBlinkRight", blink ? 1 : 0, 0.2);

    const appliedMorphTargets = [];
    if (visemeMessage && visemeMessage.visemes && visemeMessage.audioPlayer) {
      const currentTime = visemeMessage.audioPlayer.currentTime * 1000;

      for (let i = visemeMessage.visemes.length - 1; i >= 0; i--) {
        const [visemeTime, visemeId] = visemeMessage.visemes[i];
        if (currentTime >= visemeTime) {
          const targetMorph = VISME_TO_MORPHTARGET_MAP[visemeId];
          if (targetMorph) {
            appliedMorphTargets.push(targetMorph);
            lerpMorphTarget(targetMorph, 1, 0.2);
          }
          break;
        }
      }
    }

    // Reset unused morph targets
    Object.values(VISME_TO_MORPHTARGET_MAP).forEach((value) => {
      if (appliedMorphTargets.includes(value)) return;
      lerpMorphTarget(value, 0, 0.15);
    });
  });

  return (
    <group
      ref={group}
      position={position}
      scale={scale}
      rotation={rotation}
      {...props}
      dispose={null}
    >
      <group {...props} dispose={null}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <skinnedMesh
            geometry={nodes.Alpha_Joints.geometry}
            material={materials.Alpha_Joints_MAT}
            skeleton={nodes.Alpha_Joints.skeleton}
          />
          <skinnedMesh
            geometry={nodes.Alpha_Surface.geometry}
            material={materials.Alpha_Body_MAT}
            skeleton={nodes.Alpha_Surface.skeleton}
          />
          <primitive object={nodes.mixamorigHips} />
        </group>
      </group>
    </group>
  );
}

useGLTF.preload(PATH);
