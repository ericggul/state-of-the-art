/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

const PATH = "/3d/avatars-test/final_model.glb";
const ANIMATIONS_URL = "/3d/avatars-test/animations/final_animation.glb";
const ANIMATION_FADE_TIME = 0.5;

import React, { useRef, useState, useEffect } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { MathUtils } from "three";

import useBlink from "../utils/useBlink";
import useViseme from "../utils/useViseme";
import { VISME_TO_MORPHTARGET_MAP } from "../utils/constant";

export default function Model({
  position = [0, 0, 0],
  scale = [1, 1, 1],
  rotation = [0, 0, 0],
  ...props
}) {
  const group = useRef();
  const { nodes, materials } = useGLTF(PATH);
  const { animations } = useGLTF(ANIMATIONS_URL);

  const { actions, mixer } = useAnimations(animations, group);

  console.log(animations);
  console.log("ㅁㅊ샤ㅐㅜㄴ", actions);

  const [animation, setAnimation] = useState("");
  const isInitializedRef = useRef(false);

  const { visemeMessage } = useViseme();
  const { blink } = useBlink();

  // Helper function to randomly select animation
  const getRandomAnimation = (type) => {
    const animations = {
      talking: ["Armature|mixamo.com|Layer0"],
      // idle: ["Idle", "Idle2"],
    };
    const options = animations[type];
    return options[Math.floor(Math.random() * options.length)];
  };

  // Animation control
  useEffect(() => {
    if (!isInitializedRef.current) {
      isInitializedRef.current = true;
      return;
    }

    const handleAnimationChange = async () => {
      // if (!visemeMessage || visemeMessage?.audioPlayer?.paused) {
      //   if (!animation.startsWith("Idle")) {
      //     setAnimation(getRandomAnimation("idle"));
      //   }
      //   return;
      // }
      // if (visemeMessage?.audioPlayer?.paused === false) {
      //   if (!animation.startsWith("Talk")) {
      //     setAnimation(getRandomAnimation("talking"));
      //   }
      // }
    };

    handleAnimationChange();
  }, [visemeMessage?.audioPlayer?.paused, visemeMessage]);

  // Play animations
  // useEffect(() => {
  //   actions["Armature|mixamo.com|Layer0"]
  //     ?.reset()
  //     .fadeIn(mixer.time > 0 ? ANIMATION_FADE_TIME : 0)
  //     .play();
  //   return () => {
  //     actions[animation]?.fadeOut(ANIMATION_FADE_TIME);
  //   };
  // }, [animation, actions, mixer.time]);

  useEffect(() => {
    actions["Armature|mixamo.com|Layer0"].play();
  }, [animation, actions]);

  // LERP MORPH TARGET
  const lerpMorphTarget = (target, value, speed = 0.1) => {
    group.current?.traverse((child) => {
      if (child.isSkinnedMesh && child.morphTargetDictionary) {
        const index = child.morphTargetDictionary[target];
        if (
          index === undefined ||
          child.morphTargetInfluences[index] === undefined
        ) {
          return;
        }
        child.morphTargetInfluences[index] = MathUtils.lerp(
          child.morphTargetInfluences[index],
          value,
          speed
        );
      }
    });
  };

  // Handle visemes and blinking
  useFrame(() => {
    // Smile
    lerpMorphTarget("mouthSmile", 0.5, 0.2);
    // Blinking
    lerpMorphTarget("eyeBlinkLeft", blink ? 1 : 0, 0.2);
    lerpMorphTarget("eyeBlinkRight", blink ? 1 : 0, 0.2);

    const appliedMorphTargets = [];
    if (visemeMessage && visemeMessage.visemes && visemeMessage.audioPlayer) {
      const currentTime = visemeMessage.audioPlayer.currentTime * 1000;

      for (let i = visemeMessage.visemes.length - 1; i >= 0; i--) {
        const [visemeTime, visemeId] = visemeMessage.visemes[i];
        if (currentTime >= visemeTime) {
          const targetMorph = VISME_TO_MORPHTARGET_MAP[visemeId];
          if (targetMorph) {
            appliedMorphTargets.push(targetMorph);
            lerpMorphTarget(targetMorph, 1, 0.2);
          }
          break;
        }
      }
    }

    // Reset unused morph targets
    Object.values(VISME_TO_MORPHTARGET_MAP).forEach((value) => {
      if (appliedMorphTargets.includes(value)) return;
      lerpMorphTarget(value, 0, 0.15);
    });
  });

  return (
    <group
      ref={group}
      position={position}
      scale={scale}
      rotation={rotation}
      {...props}
      dispose={null}
    >
      <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
        <skinnedMesh
          geometry={nodes.Alpha_Joints.geometry}
          material={materials.Alpha_Joints_MAT}
          skeleton={nodes.Alpha_Joints.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Alpha_Surface.geometry}
          material={materials.Alpha_Body_MAT}
          skeleton={nodes.Alpha_Surface.skeleton}
        />
        <skinnedMesh
          name="EyeLeft001"
          geometry={nodes.EyeLeft001.geometry}
          material={materials["Wolf3D_Eye.001"]}
          skeleton={nodes.EyeLeft001.skeleton}
          morphTargetDictionary={nodes.EyeLeft001.morphTargetDictionary}
          morphTargetInfluences={nodes.EyeLeft001.morphTargetInfluences}
        />
        <skinnedMesh
          name="EyeRight001"
          geometry={nodes.EyeRight001.geometry}
          material={materials["Wolf3D_Eye.001"]}
          skeleton={nodes.EyeRight001.skeleton}
          morphTargetDictionary={nodes.EyeRight001.morphTargetDictionary}
          morphTargetInfluences={nodes.EyeRight001.morphTargetInfluences}
        />
        <skinnedMesh
          name="Wolf3D_Head001"
          geometry={nodes.Wolf3D_Head001.geometry}
          material={materials["Wolf3D_Skin.001"]}
          skeleton={nodes.Wolf3D_Head001.skeleton}
          morphTargetDictionary={nodes.Wolf3D_Head001.morphTargetDictionary}
          morphTargetInfluences={nodes.Wolf3D_Head001.morphTargetInfluences}
        />
        <skinnedMesh
          name="Wolf3D_Teeth001"
          geometry={nodes.Wolf3D_Teeth001.geometry}
          material={materials["Wolf3D_Teeth.001"]}
          skeleton={nodes.Wolf3D_Teeth001.skeleton}
          morphTargetDictionary={nodes.Wolf3D_Teeth001.morphTargetDictionary}
          morphTargetInfluences={nodes.Wolf3D_Teeth001.morphTargetInfluences}
        />
        <primitive object={nodes.mixamorigHips} />
      </group>
    </group>
  );
}

useGLTF.preload(PATH);
useGLTF.preload(ANIMATIONS_URL);
